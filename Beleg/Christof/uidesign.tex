\section{User Interface Design}\label{sec:design}
Eine Webseite, wie auch eine App kommt bei den Nutzern gut an, wenn sie benutzerfreundlich und bedienbar ist. Auch wenn die Anwendung die besten und neusten Funktionen bietet, wird der User daran wenig Spaß haben, wenn er die Features nicht schnell findet oder lange navigieren muss um zu seinen gewünschten Inhalten zu gelangen. Schon in den 90er Jahren hat sich Jakob Nielsen, ein dänischer Schriftsteller und mittlerweile eine der führenden Persönlichkeiten auf dem Gebiet der Benutzerfreundlichkeit, ausführlich mit dem Themen Webdesign und Usability beschäftigt. In diesem Zusammenhang erstellte er eine Liste mit zehn Grundprinzipien, die man bei der Gestaltung von Bedienoberflächen beachten sollte. Die Grundprinzipien wurden mit dem Gedanken an die Gestaltung von Webseiten erstellt, gelten aber zum Teil genauso für Apps. \\  %hier link%
\subsection{Design einer Android-App}
Auf der Google I/O 2010 präsentierte Jim Palmer das erste Mal Richtlinien, an die man sich halten kann bei der Entwicklung von Android-Apps. Sie beschreiben wie eine App auszusehen hat:
\begin{itemize}
\item einfach und verständlich
\item sich auf den Inhalt konzentrieren und nicht nur auf das Aussehen
\item konsistent sein, damit sich der Nutzer schnell zurechtfinden kann
\end{itemize}
Bei der Entwicklung der ComeTogether-App war es uns wichtig sich an diese Guidelines zu halten und somit mussten die uns zur Verfügung stehenden GUI-MockUps der zu entwickelnden App angepasst werden, bevor wir mit der Umsetzung des Frontends beginnen konnten. Dafür benutzen wir das Tool Balsamiq Mockups. Per Drag \& Drop lassen sich ganz einfach GUI-Element(Formularfelder, Navigationsleisten, Tabs usw.) auf einer Arbeitsfläche zusammenklicken. Auf der Webseite mockupstogo gibt es für Android oder iOS Erweiterungen falls die Standardelemente nicht ausreichen. 
\subsection{Sherlock ActionBar}
Ab Android 3.0(Honeycomb) ersetzt die Action Bar das Options-Menü(als Popup-Menü mit der Menü-Taste aufrufbar) sowie die Title Bar. Die Action Bar erlaubt Menus und Buttons zu platzieren und bietet die Möglichkeit sich in einen oberen und einen unteren Teil aufzuteilen. Die Action Bar ist immer am Screen sichtbar(kann mit hide() unsichtbar gemacht werden) und macht somit das User Interface konsistent, was viel dazu beiträgt das Design der App benutzerfreundlich zu gestalten. \\
Um die Action Bar auf Android 2.x nutzen zu können wurde die Open-Source-Library ActionBarSherlock entwickelt. Dabei handelt es sich um eine Erweiterung der Support Library, die es ermöglicht APIs auf älteren Android-Platformen zu nutzen. %hier link zu support library  http://developer.android.com/tools/extras/support-library.html% 
Mit der neusten Version der ActionBarSherlock(v4.1.0) soll es dem App-Entwickler möglich sein, die Action Bar aus Android 4.0(Ice Cream Sandwich) mit allen Features auf 2.x nutzbar zu machen. Auf der Projektseite von ActionBarSherlock gibt es einige Demos, sowie einen Link zur GitHub-Seite mit allen Quellcodes. Um ein Android-Projekt mit der ActionBarSherlock aufsetzen zu können geht man wie folgt vor:
\begin{enumerate}
\item Nachdem man ActionBarSherlock heruntergeladen hat, findet man einen Ordner "`library"', den man als "`new Android project - from existing source"' in Eclipse importieren muss. In diesem Projekt klickt man unter Properties/Android das Häkchen bei "`Is library"' an.
\item Im eigentlichen Android-Projekt geht man in Properties/Android und klickt auf add. Daraufhin sollte die ABS-library erscheinen und in das Projekt eingebunden werden können.
\item In der AndroidManifest.xml muss für jede activity, die die ABS haben soll, der style festgelegt werden mit der folgenden Zeile: \\
 android:theme="'@style/Theme.Sherlock.Light"'> 
 \item In dem activities wird die ABS mit extends vererbt und mit der folgenden Methode aufgerufen: \\
 \begin{verbatim}
 public boolean onCreateOptionsMenu(Menu menu) {
    ...
    } 
 \end{verbatim}
\end{enumerate}

\subsection{Hintergrundoperationen}
\subsubsection{REST-Kommunikation}
Um auf die Methoden des RESTful-Webservice zugreifen zu können werden zuerst die Instanzen von dem jeweiligen Datentyp wie beispielsweise User mit allen notwendigen Daten befüllt, %hier auf listing verweisen
anschließend wird eine Instanz des UserClient erstellt und deren Methode createUser(user) aufgerufen. Die Methode createUser erbt von der abstrakten Klasse Creator und initialisiert eine Verbindung zum Webservice mit initConnection("`http://10.0.2.2:8080/ctBackend/ctUser/createUser"') um anschließend die Methode writeProduct aufzurufen, die schließlich post.setEntity(new StringEntity(product)) ausführt und die Daten an den Server per POST sendet.
\subsubsection{UI-Thread und langlaufende Programmteile}
UI-Thread ist in einer Android-App für die Darstellung und Anwendereingaben zuständig. Alle Methoden einer Android-Komponente, die mit "`on"' beginnen, wie z.B. onClick laufen in diesem UI-Thread und dürfen nicht blockieren, das bedeutet, dass alle Methoden, die auf Oberflächenereignisse reagieren, schnell abgearbeitet werden müssen(innerhalb fünf Min.). Werden sie nicht innerhalb dieser Zeitspanne abgearbeitet, und der Nutzer drückt z.B. auf die Menütaste, dann geht Android davon aus, dass die Anwendung abgestürzt ist und der Nutzer bekommt einen Application not responding(ANR) angezeigt. Eine Lösung hierfür wäre ein eigener Thread, der in dieser onClick-Methode ausgeführt wird, damit die Anwendung möglichst schnell auf Nutzereingaben reagiert und nicht blockiert. Das Problem dabei ist, dass die Anzeige nur der UI-Thread verändern darf und jeder Zugriff von außerhalb zu einer Exception führt. Man bräuchte noch eine zusätzlichen Thread, der mit Hilfe eines Handlers eine Nachricht dem UI-Thread übergibt und dieser die Informationen aus dem ersten Thread holt und anzeigt. Denn es ist anderen Threads nicht erlaubt, Daten im UI-Thread zu verändern, da eine Veränderung des UI-Threads die Synchronisierung der Objektzustände erforderlich machen würde und somit nicht automatisch ausgeführt wird. Das ganze ist mit Threads sehr kompliziert und wird in Android auf eine einfachere Art und Weise mit Hilfe von AsyncTask gelöst.
\subsection{AsyncTask}
AsyncTask ist eine Klasse, die es ermöglicht Operationen im Hintergrund zu bearbeiten und anschließend einen Code im UI-Thread auszuführen. Um die Klasse zu nutzen muss man eine Unterklasse von AsyncTask erstellen. AsyncTask enthält drei Methoden, die in der Unterklasse überschrieben werden müssen:
\begin{itemize}
\item doInBackground(): \\
Hier steht der Code, der im Hintergrund, in einem separaten Thread, ausgeführt werden soll. Beim Aufruf mit execute() kann der Methode als Parameter ein String übergeben werden, der dann in der eigentlichen Methode in ein String-Array umgewandelt wird.
\item onProgressUpdate(): \\
Dieser Code-Abschnitt wird ausgeführt, wenn es einen Fortschritt bei der Ausführung gibt, der aus der doInBackground-Methode gemeldet wird. Der Fortschritt kann beispielsweise der prozentuale Anteil einer heruntergeladenen Datei sein. 
\item onPostExecute(): \\
Diese Methode wird aufgerufen, wenn die doInBackground-Methode abgearbeitet ist. Es handelt sich um die Benutzerschnittstelle, die dem Nutzer meldet, dass die Aufgabe erledigt worden ist. Das Argument dieses Methodenaufrufs ist der Parameter, den die doInBackground-Methode zurückliefert.
\end{itemize}
Um den AsyncTask auszuführen wir die Unterklasse instantiiert und die Methode execute() aufgerufen. Die Frage ist nun wann man AsyncTask einsetzen sollte. Ab besten ist es so viel wie möglich in den Hintergrund zu verschieben, denn der UI-Thread führt nur Änderungen an der Anzeige aus, wenn er nicht beschäftigt ist. Deswegen sollten Aufrufe, die etwas längern dauern, wie beispielsweise der Datenbankzugriff, ein Webservice-Aufruf, das Parsen eines JSON-Objekts usw. in einem AsyncTask aufgerufen werden. Mit einem Ladebalken kann dem Nutzer mitgeteilt werden wie der Fortschritt der Aufgabe ist und ihm dadurch das Gefühl vermitteln, dass die App schnell und flüssig läuft. Mit der Methode isFinishing() kann in onPostExecute() geprüft werden, ob die Activity, in der der AsyncTask läuft nicht mittlerweile beendet worden ist, weil es kann vorkommen, dass der Nutzer die Activity geschlossen hat, aber der AsyncTask noch läuft und versuchen wird die onPostExecute() auszuführen. \\
In der ComeTogether-App nutzen wir die Vorteile der AsyncTask u.a. bei Zugriffen auf den Webservice.

\subsection{Übergabe von Objekten zwischen Activities}
Nachdem ein User auf ComeTogether sich erfolgreich eingeloggt hat, liefert der Webservice ein Objekt der Klasse User. Dieses Objekt muss zwischen Activities übertragen werden und jederzeit zur Verfügung stehen.
\begin{enumerate}
\item Interface Parcelable implementieren: Damit die Instanzen der Klasse User zwischen Activities ausgetauscht werden können, muss die Klasse User das Interface Parcelable implementieren. Anschließend kann man ganz einfach mit einem Intent die Objekte an die andere Activity weiterreichen, z.B. intent.putExtra("`user"', new User()); Die Daten bokommt man aus dem Bundle folgendermaßen: Bundle data = getIntent().getExtras(); User user = data.getParcelable("`user"');
\item Objekt serializieren: Eine weitere, aber weniger ressourcenschonende Möglichkeit bietet java.io.Serializable. Die Klasse User müsste das Interface Serializable implementieren. Anschließend braucht man einen neuen Intent und Bundle. Mit der putSerializable("`user"', new User()) wird das Objekt dem Bundle hinzugefügt und mit intent.putExtras(bundle) das Bundle an das Intent angehängt. Mit startActivity(intent) wird die nächste Activity gestartet und das Objekt kann mit User user = (User)getIntent().getSerializableExtra("`user"') geholt werden.  
\item In der SQLite Datenbank speichern: Als beste und einfachste Möglichkeit das User-Objekt allen notwendigen Activities jederzeit verfügbar zu machen erwieß sich die Speicherung der User-Daten intern in der SQLite Datenbank.  
\end{enumerate}






    



